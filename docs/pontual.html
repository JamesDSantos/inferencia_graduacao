<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Inferência Estatística - um curso de graduação - 4&nbsp; Estimação pontual</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./references.html" rel="next">
<link href="./suficiencia.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./pontual.html"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Estimação pontual</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Inferência Estatística - um curso de graduação</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./summary.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Summary</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">População, amostra, famílias e inferência</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./suficiencia.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Estatística</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./pontual.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Estimação pontual</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#estimador-estimativa-erro-quadrático-médio-e-consistência" id="toc-estimador-estimativa-erro-quadrático-médio-e-consistência" class="nav-link active" data-scroll-target="#estimador-estimativa-erro-quadrático-médio-e-consistência"><span class="header-section-number">4.1</span> Estimador, estimativa, erro quadrático médio e consistência</a></li>
  <li><a href="#o-princípio-da-substituição" id="toc-o-princípio-da-substituição" class="nav-link" data-scroll-target="#o-princípio-da-substituição"><span class="header-section-number">4.2</span> O princípio da substituição</a></li>
  <li><a href="#método-dos-momentos" id="toc-método-dos-momentos" class="nav-link" data-scroll-target="#método-dos-momentos"><span class="header-section-number">4.3</span> Método dos momentos</a></li>
  <li><a href="#a-função-de-distribuição-empírica-e-o-método-bootstrap" id="toc-a-função-de-distribuição-empírica-e-o-método-bootstrap" class="nav-link" data-scroll-target="#a-função-de-distribuição-empírica-e-o-método-bootstrap"><span class="header-section-number">4.4</span> A função de distribuição empírica e o método bootstrap</a>
  <ul class="collapse">
  <li><a href="#estimação-do-erro-padrão-via-bootstrap" id="toc-estimação-do-erro-padrão-via-bootstrap" class="nav-link" data-scroll-target="#estimação-do-erro-padrão-via-bootstrap"><span class="header-section-number">4.4.1</span> Estimação do erro padrão via bootstrap</a></li>
  </ul></li>
  <li><a href="#tópicos-de-maximização-de-funções" id="toc-tópicos-de-maximização-de-funções" class="nav-link" data-scroll-target="#tópicos-de-maximização-de-funções"><span class="header-section-number">4.5</span> Tópicos de maximização de funções*</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Estimação pontual</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="estimador-estimativa-erro-quadrático-médio-e-consistência" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="estimador-estimativa-erro-quadrático-médio-e-consistência"><span class="header-section-number">4.1</span> Estimador, estimativa, erro quadrático médio e consistência</h2>
<p>A palavra estimar possui vários significados na língua portuguesa. Em um de seus verbetes, estimar significa apreciação ou avaliação. Neste sentido, a estimação pontual refere-se a um conjunto de técnicas para encontrar uma estatística para avaliar alguma característica da população.</p>
<div class="alert alert-success">
<p><strong>Definição</strong> Estimador é uma estatística criada com o objetivo de estimar os parâmetros populacionais. Seu valor observado é denominado estimativa.</p>
</div>
<p>Por ser uma estatística, o estimador possui uma distribuição amostral. Considerando seu objetivo primário de estimar <span class="math inline">\(\theta\)</span>, é natural que o estimador produza estimativas próximas deste valor.</p>
<p>Seja <span class="math inline">\(T\)</span> um estimador para <span class="math inline">\(\theta\)</span>. Definimos o erro quadrático médio por</p>
<p><span class="math display">\[EQM_T(\theta)=E(T-\theta)^2.\]</span> Quanto menor for o erro quadrático médio, maior é a capacidade do estimador produzir, em média, estimativas próximas de <span class="math inline">\(\theta\)</span>. Pode-se notar que</p>
<p><span class="math display">\[\begin{align}EQM_T(\theta)&amp;=E\left(T-E(T)+E(T)-\theta\right)^2\\&amp;=E\left( (T-E(T))^2+(E(T)-\theta)^2- (T-E(T))(E(T)-\theta)\right)\\&amp;=Var(T)+(E(T)-\theta)^2\\&amp;=SE(T)^2+\hbox{Vício}_T(\theta)^2.\end{align}\]</span> onde <span class="math display">\[\hbox{Vício}_T(\theta)=E(T)-\theta\]</span> e <span class="math display">\[SE(T)=\sqrt{Var(T)}.\]</span></p>
<p>Vamos analisar as parcelas dessa decomposição em separado. O termo <span class="math inline">\(E(T)-\theta\)</span> é denominado vício (do estimador). - Se o vício é nulo, o estimador é dito ser não viciado. - Se o vício é positivo, o estimador tende a superestimar <span class="math inline">\(\theta\)</span>. - Se o vício é negativo, o estimador tende a subestimar <span class="math inline">\(\theta\)</span>. O termo <span class="math inline">\(SE(T)\)</span> é denominado erro padrão (<em>standard error</em>) e é uma medida de acurácia do estimador.</p>
<div class="alert alert-warning">
<p><strong>Nota.</strong> O erro quadrático médio é utilizado para comparar estimadores. Já o erro padrão é uma importante medida que precisa ser reportada junto com a estimativa pontual.</p>
</div>
<div class="alert alert-info">
<p><strong>Exemplo.</strong> Seja <span class="math inline">\(X_1,\ldots,X_n\)</span> uma amostra aleatória de um membro da família de distribuições com variância finita. Sejam <span class="math inline">\(E(X)=\mu\)</span> e <span class="math inline">\(\sigma^2=Var(X)\)</span>. Considere o estimador <span class="math inline">\(\bar{X}_n\)</span> para <span class="math inline">\(\mu\)</span>. Como a família não é paramétrica, não sabemos a distribuição amostral de <span class="math inline">\(\bar{X}_n\)</span>. Contudo, tem-se que <span class="math display">\[E(\bar{X}_n)=E\left(\frac{1}{n}\sum_{i=1}^n X_i\right)=\frac{1}{n}\sum_{i=1}^nE(X_i)=E(X)=\mu\]</span> logo, o estimador <span class="math inline">\(\bar{X}_n\)</span> é não viciado para <span class="math inline">\(\mu\)</span>. Além disso, <span class="math display">\[Var(\bar{X}_n)=Var\left(\frac{1}{n}\sum_{i=1}^{n}X_i\right)=\frac{1}{n^2}\sum_{i=1}^n Var(X_i)=\frac{\sigma^2}{n}\]</span> logo, o erro quadrático de <span class="math inline">\(\bar{X}\)</span> é <span class="math display">\[EQM_{\bar{X}_n}(\mu)=\frac{\sigma^2}{n}.\]</span> Observe que esse erro quadrático médio é inversamente proporcional ao tamanho da amostra. Portanto, quanto maior o tamanho da amostra, mais próximas de <span class="math inline">\(\mu\)</span> estarão as estimativas produzidas por <span class="math inline">\(\bar{X}_n\)</span>.</p>
<p>O erro padrão é dado por <span class="math display">\[SE(\bar{X}_n)=\frac{\sigma}{\sqrt{n}},\]</span> mas só pode ser reportado se <span class="math inline">\(\sigma\)</span> for conhecido. É possível mostrar que, sob as mesmas condições, o estimador <span class="math display">\[S^2=\frac{1}{n-1}\sum_{i=1}^n (X_i-\bar{X}_n)^2\]</span> é não viciado para <span class="math inline">\(\sigma^2\)</span>.</p>
</div>
<p>No exemplo acima, vimos que o erro quadrático médio de <span class="math inline">\(\bar{X}_n\)</span> tende a zero na medida que aumentamos o tamanho da amostra. Estimadores com essa característica são denominados consistentes.</p>
<div class="alert alert-success">
<p>Uma sequência <span class="math inline">\(T_n=T_n(X_1,\ldots,X_n)\)</span> de estimadores para <span class="math inline">\(\theta\)</span> é consistente se, para qualquer <span class="math inline">\(\varepsilon&gt;0\)</span> e <span class="math inline">\(\theta\in\Theta\)</span>, <span class="math display">\[\lim_{n\rightarrow\infty} P(|T_n-\theta|&lt;\varepsilon)=1.\]</span></p>
</div>
<p>Intuitivamente, quanto maior é o tamanho da amostra, maior é a probabilidade do estimador estar arbitrariamente próximo de <span class="math inline">\(\theta\)</span>. O resultado abaixo relaciona a consistência com o erro quadrático médio.</p>
<div class="alert alert-success">
<p><strong>Proposição.</strong> Seja <span class="math inline">\(T_n=T(X_1,\ldots,X_n)\)</span> uma sequência de estimadores. Se, para todo <span class="math inline">\(\theta\)</span>, <span class="math display">\[\lim_{n\rightarrow\infty}EQM_{T_n}(\theta)=0,\]</span> então <span class="math inline">\(T_n\)</span> é consistente.</p>
</div>
<div class="alert alert-info">
<p><strong>Exemplo</strong>. Considere uma amostra aleatória de uma população com variância finita. Mostramos anteriormente que <span class="math display">\[EQM_{\bar{X}_n}(\mu)=\frac{\sigma}{n}.\]</span> Como <span class="math display">\[\lim_{n\rightarrow\infty}\frac{\sigma}{n}=0,\]</span> temos que <span class="math inline">\(\bar{X}_n\)</span> é um estimador consistente.</p>
</div>
</section>
<section id="o-princípio-da-substituição" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="o-princípio-da-substituição"><span class="header-section-number">4.2</span> O princípio da substituição</h2>
<p>Discutimos anteriormente que as características de interesse presentes na população são funções dos parâmetros populacionais. Ao se obter uma estimativa para <span class="math inline">\(\theta\)</span>, é natural que essa estimativa seja utilizadas para estimar qualquer função de <span class="math inline">\(\theta\)</span>.</p>
<div class="alert alert-success">
<p><strong>Princípio da substituição.</strong> Seja <span class="math inline">\(T\)</span> uma estimador para <span class="math inline">\(\theta\)</span>. Então, para qualquer função real <span class="math inline">\(g(.)\)</span>, <span class="math inline">\(g(T)\)</span> será um estimador para <span class="math inline">\(g(\theta)\)</span>.</p>
</div>
<div class="alert alert-info">
<p><strong>Exemplo</strong> Considere novamente uma amostra aleatória de um membro da família de distribuições com variância finita. Vimos que <span class="math inline">\(S^2_n\)</span> é um estimador não viciado para <span class="math inline">\(Var(X)=\sigma^2\)</span>. Então, pelo princípio da substituição, <span class="math display">\[S_n=\sqrt{S^2_n}\]</span> é um estimador para <span class="math inline">\(\sigma\)</span>. Também vimos que <span class="math inline">\(\bar{X}_n\)</span> é um estimador para <span class="math inline">\(\mu=E(X)\)</span> e que seu erro padrão é <span class="math display">\[SE(\bar{X}_n)=\frac{\sigma}{\sqrt{n}}.\]</span> Logo, um estimador para erro padrão de <span class="math inline">\(\bar{X}_n\)</span> é</p>
<p><span class="math display">\[\widehat{SE}(\bar{X}_n)(\mu)=\frac{S_n}{\sqrt{n}}.\]</span></p>
</div>
<div class="alert alert-info">
<p><strong>Exemplo.</strong> Foram coletados o peso em gramas de 100 bebês recém-nascidos no estado do Amazonas em 2010. A estimativa obtida para a média foi <span class="math inline">\(\bar{x}=3.226,85 g\)</span>. O desvio padrão amostral foi 474,556. Logo, o erro padrão estimado para a média foi</p>
<p><span class="math display">\[\hat{SE}(\bar{X}_n)=\frac{474,556g}{\sqrt{100}}=47,4556g.\]</span> Portanto, a estimativa possui um erro de 47,4556<span class="math inline">\(g\)</span>. É usual escrever <span class="math inline">\(3.226,85g\pm47,4556g\)</span>.</p>
<p>Isso implica que há evidências de que nossa estimativa está correta na casa das unidades de milhar, mas pode conter erros nas casas anteriores. A estratégia para diminuir o erro padrão é aumentar o tamanho da amostra.</p>
</div>
<p>Seja <span class="math inline">\(T\)</span> um estimador para <span class="math inline">\(\theta\)</span> e considere novamente o problema de estimar <span class="math inline">\(g(\theta)\)</span>. O valor da função <span class="math inline">\(g(.)\)</span> quando <span class="math inline">\(t\)</span> está na vizinhança de <span class="math inline">\(\theta\)</span> pode ser aproximado por <span class="math display">\[g(t)\approx g(\theta)+(t-\theta)g'(\theta),\]</span> onde <span class="math inline">\(g'\)</span> é derivada de <span class="math inline">\(g\)</span>. Observe que <span class="math display">\[g(t)-g(\theta)\approx (t-\theta)g'(\theta),\]</span> logo <span class="math display">\[\underbrace{E\left(g(T_n)-g(\theta)\right)^2}_{EQM_{g(T_n)}(g(\theta))}\approx \underbrace{E\left(T-\theta\right)^2}_{EQM_{T_n}(\theta)} [g'(\theta)]^2\]</span></p>
<p>Portanto, se <span class="math inline">\(T_n\)</span> for consistente, então <span class="math inline">\(g(T_n)\)</span> também será consistente. Além disso, pode-se mostrar que<br>
<span class="math display">\[\underbrace{E(g(T_n))-g(\theta)}_{\hbox{Vício}_{g(T_n)}(g(\theta))}\approx \underbrace{(E(T_n )-\theta)}_{\hbox{Vício}_{T_n}(\theta)}g'(\theta),\]</span> e, se <span class="math inline">\(T_n\)</span> é não viciado, teremos que <span class="math inline">\(g(T_n)\)</span> será aproximadamente não viciado. Além disso,</p>
<span class="math display">\[Var(g(T_n))\approx \underbrace{E(T_n-\theta)^2}_{EQM_{T_n}(\theta)}g'(\theta)^2.\]</span> e, se <span class="math inline">\(T_n\)</span> é não viciado, o erro padrão de <span class="math inline">\(g(T_n)\)</span> é aproximado por <span class="math display">\[SE(g(T_n))\approx SE(T_n)|g'(\theta)|.\]</span>
<div class="alert alert-warning">
<p><strong>Importante.</strong> A aproximação <span class="math display">\[g(t)-g(\theta)\approx (t-\theta)g'(\theta)\]</span> é razoável apenas quando <span class="math inline">\(t\)</span> está na vizinhança de <span class="math inline">\(\theta\)</span>. Para que os resultados utilizando esperança e variância sejam razoáveis, é necessário que a distribuição amostral de <span class="math inline">\(T_n\)</span> esteja bem concentrada em torno de <span class="math inline">\(\theta\)</span>, o que é obtido na prática com um tamanho grande de amostra, desde que <span class="math inline">\(T_n\)</span> seja consistente.</p>
</div>
</section>
<section id="método-dos-momentos" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="método-dos-momentos"><span class="header-section-number">4.3</span> Método dos momentos</h2>
<p>O <span class="math inline">\(k\)</span>-ésimo momento da população é definido por <span class="math inline">\(\mu_k=E(X^k)\)</span>. Defina o <span class="math inline">\(k\)</span>-ésimo momento amostral por <span class="math display">\[\hat{\mu}_k=\frac{1}{n}\sum_{i=1}^n X_i^k\]</span> Observe que, ao fazer <span class="math inline">\(X_i^k=Y_i\)</span>, teremos que <span class="math inline">\(\hat{\mu}_k=\bar{Y}_n\)</span>. Isso nos permite provar que:</p>
<ul>
<li><span class="math inline">\(\hat{\mu}_k\)</span> é um estimador não viciado para <span class="math inline">\(\mu_k\)</span></li>
<li><span class="math inline">\(SE(\hat{\mu})=\sqrt{Var(X^k)/n}\)</span></li>
<li><span class="math inline">\(EQM_{\hat{\mu}_k}(\mu_k)=Var(X^k)/n\)</span></li>
<li><span class="math inline">\(\hat{\mu}_k\)</span> é consistente</li>
</ul>
<p>Além disso, para <span class="math inline">\(n\)</span> suficientemente grande, pelo Teorema Central do Limite <span class="math display">\[\hat{\mu}_k\approx \hbox{Normal}\left(\mu_k,\frac{Var(X^k)}{n}\right)\]</span></p>
<div class="alert alert-info">
<p><strong>Exemplo</strong> Seja <span class="math inline">\(X_1,\ldots,X_n\)</span> uma amostra aleatória da população Poisson(<span class="math inline">\(\lambda\)</span>). Sabemos que o primeiro momento populacional é <span class="math inline">\(E(X)=\lambda\)</span>. Logo, a média amostral é um estimador não viciado e consistente para <span class="math inline">\(\lambda\)</span>. Além disso, como <span class="math display">\[Var(X)=\lambda,\]</span> para <span class="math inline">\(n\)</span> suficientemente grande,</p>
<p><span class="math display">\[\bar{X}\approx \hbox{Normal}\left(\lambda,\frac{\lambda}{n}\right).\]</span> Note que é possível trabalhar com a distribuição exata de <span class="math inline">\(\bar{X}_n\)</span>, uma vez que <span class="math display">\[\sum_{i=1}^n X_i\sim\hbox{Poisson}(n\lambda)\]</span> e <span class="math display">\[P(\bar{X}_n=\bar{x}|\lambda)=P\left(\left.\sum_{i=1}^n X_i=n\bar{x}\right|\lambda\right).\]</span></p>
</div>
<p>Considere uma amostra aleatória de uma população com parâmetros <span class="math inline">\(\theta_1,\ldots,\theta_k\)</span>. Suponha que os <span class="math inline">\(k\)</span> primeiros momentos podem ser escritos como função dos parâmetros, ou seja, existem funções <span class="math inline">\(g_j(.)\)</span>, <span class="math inline">\(j=1,\ldots,k\)</span> tais que <span class="math display">\[\mu_k=g_j(\theta_1,\ldots,\theta_k).\]</span> Suponha ainda que existem funções <span class="math inline">\(h_j(.)\)</span>, <span class="math inline">\(j=1,\ldots,k\)</span>, tais que <span class="math display">\[\theta_j=h_j(\mu_1,\ldots,\mu_k).\]</span> O método dos momentos consiste em encontrar os estimadores <span class="math inline">\(\hat{\theta}_1,\ldots,\hat{\theta}_k\)</span> computando <span class="math display">\[\hat{\theta}_j=h_j(\hat{\mu}_1,\ldots,\hat{\mu}_k).\]</span></p>
<p>Em outras palavras, o método dos momentos consiste em utilizar os momentos amostrais e aplicar o princípio da substituição para obter estimativas dos parâmetros. Como os momentos amostrais são não viciados e consistentes, podemos obter as seguintes propriedades:</p>
<ol type="1">
<li><span class="math inline">\(\hat{\theta}_j\)</span> é aproximadamente não viciado</li>
<li><span class="math inline">\(\hat{\theta}_j\)</span> é consistente</li>
</ol>
<p>Além disso, a distribuição amostral dos estimadores de momentos é aproximadamente normal. Quando há apenas um parâmetro, essa aproximação é dada por</p>
<p><span class="math display">\[\hat{\theta}\approx \hbox{Normal}\left( \theta_j,\frac{Var(X)}{n}\left[\frac{d}{d\mu}h(\mu)\right]^2 \right).\]</span></p>
<div class="alert alert-info">
<p><strong>Exemplo</strong> Seja <span class="math inline">\(X_1,\ldots,X_n\)</span> uma amostra aleatória da população Exponencial(<span class="math inline">\(\theta\)</span>). O primeiro momento amostral é <span class="math display">\[\mu=E(X)=\frac{1}{\theta}=g(\theta).\]</span> Podemos então escrever <span class="math inline">\(\theta\)</span> como função do primeiro momento amostral: <span class="math display">\[\theta=\frac{1}{\mu}=h(\mu)\]</span> Logo, o estimador obtido via método dos momentos para <span class="math inline">\(\theta\)</span> é <span class="math display">\[\hat{\theta}=\frac{1}{\hat{\mu}}=\frac{1}{\bar{X}_n}.\]</span> Como <span class="math display">\[Var(X)=\frac{1}{\theta^2}\]</span> e <span class="math display">\[\frac{d}{d\mu}h(\mu)=-\frac{1}{\mu}^2=\left(\frac{1}{\mu}\right)^2=\theta^2,\]</span> teremos que, para <span class="math inline">\(n\)</span> suficientemente grande, sua distribuição amostral será <span class="math display">\[\hat{\theta}\approx N\left(\theta,\frac{Var(X)}{n}h'(\mu)^2\right)=N\left(\theta,\frac{\theta^2}{n}\right)\]</span></p>
</div>
<div class="alert alert-info">
<p><strong>Exemplo</strong> Seja <span class="math inline">\(X_1,\ldots,X_n\)</span> uma amostra aleatória da população Geométrica(<span class="math inline">\(\theta\)</span>). O primeiro momento amostral é <span class="math display">\[\mu=E(X)=\frac{1-\theta}{\theta}=g(\theta).\]</span> Podemos então escrever <span class="math inline">\(\theta\)</span> como função do primeiro momento amostral: <span class="math display">\[\theta=\frac{1}{1+\mu}=h(\mu)\]</span> Logo, o estimador obtido via método dos momentos para <span class="math inline">\(\theta\)</span> é <span class="math display">\[\hat{\theta}=\frac{1}{1+\hat{\mu}}=\frac{1}{1+\bar{X}_n}.\]</span> Como <span class="math display">\[Var(X)=\frac{1-\theta}{\theta^2},\]</span> e <span class="math display">\[\frac{d}{d\mu}h(\mu)=-\frac{1}{(1+\mu)^2}=\left(\frac{1}{1+\mu}\right)^2=\theta^2,\]</span> teremos que, para <span class="math inline">\(n\)</span> suficientemente grande, sua distribuição amostral será <span class="math display">\[\hat{\theta}\approx N\left(\theta,\frac{Var(X)}{n}h'(\mu)^2\right)=N\left(\theta,\frac{\theta^2(1-\theta)}{n}\right)\]</span></p>
<p>É possível encontrar a distribuição exata de <span class="math inline">\(\hat{\theta}\)</span>. Para tanto, lembremos que <span class="math display">\[\sum_{i=1}^n X_i\sim \hbox{Binomial Negativa}(n,\theta),\]</span> logo, <span class="math display">\[\begin{align}P\left(\hat{\theta}=c|\theta\right)&amp;=P\left(\left.\frac{1}{1+\bar{X}_n}=c\right|\theta\right)=P\left(\left.\bar{X}_n=\frac{1}{c}-1\right|\theta\right)\\&amp;=
P\left(\left.\sum_{i=1}^n X_i=n\left(\frac{1}{c}-1\right)\right|\theta\right).
\end{align}\]</span></p>
</div>
<div class="alert alert-info">
<p><strong>Exemplo.</strong> Seja <span class="math inline">\(X_1,\ldots,X_n\)</span> uma amostra aleatória da distribuição Gama(<span class="math inline">\(\alpha,\beta\)</span>). A esperança e a variância desse modelo são <span class="math display">\[E(X)=\frac{\alpha}{\beta}\]</span> e <span class="math display">\[Var(X)=\frac{\alpha}{\beta^2}.\]</span> Como <span class="math inline">\(E(X^2)=Var(X)+E(X)^2\)</span>, podemos deduzir que <span class="math display">\[E(X^2)=\frac{\alpha^2+\alpha}{\beta^2}.\]</span> Então, os dois primeiros momentos escritos como função de <span class="math inline">\(\alpha\)</span> e <span class="math inline">\(\beta\)</span> são <span class="math display">\[\begin{align}\mu_1&amp;=\frac{\alpha}{\beta^2}=g_1(\alpha,\beta),\\
\mu_2&amp;=\frac{\alpha^2+\alpha}{\beta^2}=g_2(\alpha,\beta).\end{align}\]</span> Podemos então escrever <span class="math inline">\(\alpha\)</span> e <span class="math inline">\(\beta\)</span> como função de <span class="math inline">\(\mu_1\)</span> e <span class="math inline">\(\mu_2\)</span>: <span class="math display">\[\begin{align}\alpha&amp;=\frac{\mu_1^2}{\mu_2-\mu_1^2}=\frac{\mu_1^2}{Var(X)}=h_1(\mu_1,\mu_2),\\
\beta&amp;=\frac{\mu_1}{\mu_2-\mu_1^2}=\frac{\mu_1}{Var(X)}=h_2(\mu_1,\mu_2).\end{align}\]</span> Portanto os estimadores para <span class="math inline">\(\alpha\)</span> e <span class="math inline">\(\beta\)</span> obtidos via método dos momentos são: <span class="math display">\[\begin{align}\hat{\alpha}&amp;=\frac{\bar{X}_n^2}{S^2_n}=h_1(\mu_1,\mu_2),\\
\hat{\beta}&amp;=\frac{\bar{X}_n}{S^2_n}=h_2(\mu_1,\mu_2).\end{align}.\]</span></p>
</div>
<div class="alert alert-info">
<p><strong>Exemplo.</strong> Seja <span class="math inline">\(X_1,\ldots,X_n\)</span> uma amostra aleatória da distribuição Beta(<span class="math inline">\(\alpha,\beta\)</span>). A esperança e a variância desse modelo são <span class="math display">\[E(X)=\frac{\alpha}{\alpha+\beta}\]</span> e <span class="math display">\[Var(X)=\frac{\alpha\beta}{(\alpha+\beta)^2(\alpha+\beta+1)}.\]</span> Como <span class="math inline">\(E(X^2)=Var(X)+E(X)^2\)</span>, podemos deduzir que <span class="math display">\[E(X^2)=\frac{\alpha^2}{(\alpha+\beta)^2}+\frac{\alpha\beta}{(\alpha+\beta)^2(\alpha+\beta+1)}.\]</span> Então, os dois primeiros momentos escritos como função de <span class="math inline">\(\alpha\)</span> e <span class="math inline">\(\beta\)</span> são <span class="math display">\[\begin{align}\mu_1&amp;=\frac{\alpha}{\alpha+\beta}=g_1(\alpha,\beta),\\
\mu_2&amp;=\frac{\alpha^2}{(\alpha+\beta)^2}+\frac{\alpha\beta}{(\alpha+\beta)^2(\alpha+\beta+1)}=g_2(\alpha,\beta).\end{align}\]</span> Podemos então escrever <span class="math inline">\(\alpha\)</span> e <span class="math inline">\(\beta\)</span> como função de <span class="math inline">\(\mu_1\)</span> e <span class="math inline">\(\mu_2\)</span>: <span class="math display">\[\begin{align}\alpha&amp;=\frac{\mu_1^2-\mu_1\mu_2}{\mu_2-\mu_1^2}=\mu_1\left(\frac{\mu_1(1-\mu_1)}{Var(X)}-1\right)=h_1(\mu_1,\mu_2),\\
\beta&amp;=(1-\mu_1)\left(\frac{\mu_1(1-\mu_1)}{Var(X)}-1\right)=h_2(\mu_1,\mu_2).\end{align}\]</span> Portanto os estimadores para <span class="math inline">\(\alpha\)</span> e <span class="math inline">\(\beta\)</span> obtidos via método dos momentos são: <span class="math display">\[\begin{align}\hat{\alpha}&amp;=\bar{X}_n\left(\frac{\bar{X}_n(1-\bar{X}_n)}{S_n^2}-1\right),\\
\hat{\beta}&amp;=(1-\bar{X}_n)\left(\frac{\bar{X}_n(1-\bar{X}_n)}{S_n^2}-1\right).\end{align}\]</span></p>
</div>
<p>Para o caso de <span class="math inline">\(q\)</span> parâmetros, é possível mostrar que a distribuição aproximada dos estimadores de momentos é</p>
<p><span class="math display">\[\hat{\theta}_j\approx \hbox{Normal}\left(\theta_j,\frac{1}{n}\sum_{r=1}^k\sum_{s=1}^k\sigma_{r,s}\frac{\partial}{\partial\mu_r}h_j\frac{\partial}{\partial\mu_s}h_j\right),\]</span> onde <span class="math display">\[\sigma_{r,s}=Cov(X^r,X^s).\]</span></p>
</section>
<section id="a-função-de-distribuição-empírica-e-o-método-bootstrap" class="level2" data-number="4.4">
<h2 data-number="4.4" class="anchored" data-anchor-id="a-função-de-distribuição-empírica-e-o-método-bootstrap"><span class="header-section-number">4.4</span> A função de distribuição empírica e o método bootstrap</h2>
<p>Seja <span class="math inline">\(X_1,\ldots,X_n\)</span> uma amostra alestória da população, cuja função distribuição, denotada por <span class="math inline">\(F\)</span>, é desconhecida. Nesse caso, <span class="math inline">\(F\)</span> pertence à classe de todas as funções de distribuição.</p>
<div class="alert alert-success">
<p><strong>Definição.</strong> A função de distribuição empírica (FDE) é definida por <span class="math display">\[\hat{F}_{n}(x)=\frac{1}{n}\sum_{i=1}^n I(X_i\leq x).\]</span></p>
</div>
<p>Observe que a função de distribuição empírica é uma estatística, cuja distribuição empírica se altera para cada valor de <span class="math inline">\(x\)</span> fixado. É importante notar que <span class="math inline">\(x\)</span> é o argumento da função e não está relacionado com a amostra observada. O valor observado dessa estatística, para <span class="math inline">\(x\)</span> fixado, recebe a mesma notação:</p>
<p><span class="math display">\[\hat{F}_{n}(x)=\frac{1}{n}\sum_{i=1}^n I(x_i\leq x).\]</span> Nos textos básicos de estatística, <span class="math inline">\(\hat{F}_n(x)\)</span> é comumente denominada função de distribuição acumulada.</p>
<p>Observe que</p>
<p><span class="math display">\[E(\hat{F}_{n}(x))=\frac{1}{n}\sum_{i=1}^n E(I(X_i\leq x))=E(I(X\leq x))=0.P(X&gt;x)+1.P(X\leq 1)=F(x),\]</span> logo, a função de distribuição empírica é um estimador não viciado para a população. Além disso,</p>
<p><span class="math display">\[\begin{align}Var(\hat{F}_{n}(x))&amp;=\frac{1}{n^2}\sum_{i=1}^n Var(I(X_i\leq x))=\frac{1}{n}Var(I(X\leq x))\\&amp;=\frac{1}{n}\left[(0-F(x))^2.P(X&gt;x)+(1-F(x))^2.P(X\leq x)\right]\\&amp;=\frac{1}{n}\left[F(x)^2(1-F(x))+F(x)+F(x)^3-2F(x)^2\right]\\&amp;=\frac{1}{n}\left[F(x)-F(x)^2\right]=\frac{1}{n}F(x)(1-F(x)),\end{align}\]</span> portanto, para qualquer valor de <span class="math inline">\(x\)</span> fixado, <span class="math display">\[\lim_{n\rightarrow\infty }EQM_{\hat{F}_n}(F)=0,\]</span> e <span class="math inline">\(\hat{F}_n\)</span> é um estimador consistente.</p>
<p>A função de distribuição empírica é equivalente a função de distribuição obtida quando consideramos que cada ponto de uma amostra observada de tamanho <span class="math inline">\(n\)</span> possui probabilidade <span class="math inline">\(1/n\)</span>.</p>
<div class="alert alert-info">
<p><strong>Exemplo.</strong> O banco de dados abaixo possui o peso, em gramas, de 37.439 bebês nascidos no Amazonas em 2010 com mais de 47 semanas de gestação.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>url <span class="ot">&lt;-</span> <span class="st">'https://docs.google.com/spreadsheets/d/1mEpPFyVaU3DjwYvWGhZDS_0EsESLRERSed475P-_29U/edit?usp=sharing'</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span>(gsheet)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Carregando pacotes exigidos: gsheet</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning: package 'gsheet' was built under R version 4.3.2</code></pre>
</div>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>dados <span class="ot">&lt;-</span>  <span class="fu">gsheet2tbl</span>(url)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>O comando <code>ecdf</code> retorna a função de distribuição empírica da amostra. Abaixo, mostramos o gráfico dessa função estimada.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>Fn <span class="ot">&lt;-</span> <span class="fu">ecdf</span>(dados<span class="sc">$</span>PESO)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>( Fn, <span class="at">main =</span> <span class="st">' '</span>, <span class="at">xlab =</span> <span class="st">'Peso'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="pontual_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Observe na figura acima o típico formato em S esperado pela função de distribuição da distribuição normal. Assumindo que os dados são provenientes de uma população normal, podemos utilizar o princípio da substituição e estimar sua função por <span class="math display">\[\tilde{F}_n(x)=\int_{-\infty}^x \frac{1}{\sqrt{2\pi s_n^2}}e^{-\frac{1}{2s_n^2}(x-\bar{x})^2}.\]</span> Portanto, temos duas estimativas para a função de distribuição. Comparar as duas é a base dos testes de bondade de ajuste. Se as duas diferem, temos evidências de que o modelo paramétrico escolhido não é adequado. A figura abaixo faz o gráfico de <span class="math inline">\(\hat{F}_n\)</span> e <span class="math inline">\(\tilde{F}_n\)</span>, monstrando que há evidências de que os dados são provenientes de uma população normal.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>Fn <span class="ot">&lt;-</span> <span class="fu">ecdf</span>(dados<span class="sc">$</span>PESO)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>Ftil <span class="ot">&lt;-</span> <span class="cf">function</span>(x) <span class="fu">pnorm</span>(x, <span class="fu">mean</span>(dados<span class="sc">$</span>PESO), <span class="fu">sd</span>(dados<span class="sc">$</span>PESO))</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>( Fn, <span class="at">main =</span> <span class="st">' '</span>, <span class="at">xlab =</span> <span class="st">'Peso'</span>, <span class="at">lwd =</span> <span class="dv">2</span>, <span class="at">col =</span><span class="st">'darkorange4'</span>)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="fu">curve</span>(<span class="fu">Ftil</span>(x), <span class="at">add=</span>T, <span class="at">col =</span><span class="st">'seagreen'</span>, <span class="at">lwd =</span> <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="pontual_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</div>
<section id="estimação-do-erro-padrão-via-bootstrap" class="level3" data-number="4.4.1">
<h3 data-number="4.4.1" class="anchored" data-anchor-id="estimação-do-erro-padrão-via-bootstrap"><span class="header-section-number">4.4.1</span> Estimação do erro padrão via bootstrap</h3>
<p>Seja <span class="math inline">\(X_1,\ldots,X_n\)</span> uma amostra aleatória e seja <span class="math inline">\(T\)</span> uma estatística. Sabemos que o erro padrão de <span class="math inline">\(T\)</span> é uma importante da qualidade de <span class="math inline">\(T\)</span>. Entretando, nem sempre é trivial obter uma estimativa para o erro padrão.</p>
<p>Suponha que é possível repetir esse experimento <span class="math inline">\(B\)</span> vezes e seja <span class="math inline">\(t_i\)</span> o valor observado da estatística na <span class="math inline">\(i\)</span>-ésima repetição. Então, o erro padrão poderia ser facilmente estimado por</p>
<p><span class="math display">\[\widehat{SE}(T)=\sqrt{\frac{1}{B-1}\sum_{i=1}^B(t_i-\bar{t})^2},\]</span> onde <span class="math inline">\(\bar{t}\)</span> é a média amostral de <span class="math inline">\(t_1,\ldots,t_B\)</span>.</p>
<p>Em geral não é possível repetir o experimento várias vezes. Em vez disso, podemos simular novas amostras considerando que a verdadeira distribuição é <span class="math inline">\(\hat{F}_n(.)\)</span>. Cada amostra aleatória simulada é obtida via amostragem aleatória simples com reposição considerando a amostra original. O cálculo do erro padrão utilizando os valores de <span class="math inline">\(t\)</span> obtidos deste modo é denominado bootstrap</p>
<div class="alert alert-danger">
<p><strong>Algoritmo: Metodo bootstrap</strong></p>
<p>Seja <span class="math inline">\(x_1,\ldots,x_n\)</span> a amostra observada. Para <span class="math inline">\(i=1,\ldots,B\)</span></p>
<ul>
<li><p>Passo <span class="math inline">\(i\)</span>: colete <span class="math inline">\(x_1^*,\ldots,x_n^*\)</span> utilizando uma amostragem aleatória simples com reposição de <span class="math inline">\(x_1,\ldots,x_n\)</span>. Calcule <span class="math inline">\(t_i=T(x_1^*,\ldots,x_n^*)\)</span></p></li>
<li><p>Calcule</p></li>
</ul>
<p><span class="math display">\[\widehat{SE}(T)=\sqrt{\frac{1}{B-1}\sum_{i=1}^B(t_i-\bar{t})^2}\]</span></p>
</div>
<div class="alert alert-info">
<p><strong>Exemplo.</strong> Considere o seguinte subconjunto da amostra utilizada no exemplo anterior:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>amostra <span class="ot">&lt;-</span> dados<span class="sc">$</span>PESO[<span class="dv">1</span><span class="sc">:</span><span class="dv">30</span>]</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>amostra</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] 3230 3960 3070 3670 3770 3135 3095 3085 3095 3405 3575 2600 3645 3255 3140
[16] 3070 2970 2650 3195 3450 3125 3130 3370 2960 2945 2965 2795 3195 3680 2825</code></pre>
</div>
</div>
<p>Podemos obter uma amostra da função de distribuição empírica sorteando 30 dos números acima ao acaso com reposição</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>sorteio <span class="ot">&lt;-</span> <span class="fu">sample</span>(amostra, <span class="dv">30</span>, T)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>sorteio</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] 3085 3195 2795 2795 3230 3195 3095 3070 3370 2960 3770 3370 2825 2945 3370
[16] 3195 3140 3405 3070 3140 2970 3960 3450 3575 3450 2970 2795 3085 3370 3450</code></pre>
</div>
</div>
<p>Vamos calcular o erro padrão de <span class="math inline">\(\bar{X}_{30}\)</span> utilizano do método bootstrap:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>t <span class="ot">&lt;-</span> <span class="cn">NULL</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>B <span class="ot">&lt;-</span> <span class="dv">10000</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>( i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>B){ </span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>sorteio <span class="ot">&lt;-</span> <span class="fu">sample</span>(amostra, <span class="dv">30</span>, T)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>t[i] <span class="ot">&lt;-</span> <span class="fu">mean</span>(sorteio)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="co"># erro padrão</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="fu">sd</span>(t)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 58.7555</code></pre>
</div>
</div>
<p>Compare esse valor com o erro padrão estimado por <span class="math inline">\(S_n/\sqrt{30}\)</span>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sd</span>(amostra)<span class="sc">/</span><span class="fu">sqrt</span>(<span class="dv">30</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 59.83766</code></pre>
</div>
</div>
</div>
</section>
</section>
<section id="tópicos-de-maximização-de-funções" class="level2" data-number="4.5">
<h2 data-number="4.5" class="anchored" data-anchor-id="tópicos-de-maximização-de-funções"><span class="header-section-number">4.5</span> Tópicos de maximização de funções*</h2>
<p>Seja <span class="math inline">\(f(.)\)</span> uma função real. Dizemos que <span class="math inline">\(x^*\)</span> é um ponto de máximo global se, para todo <span class="math inline">\(x\)</span> no domínio de <span class="math inline">\(f\)</span>, <span class="math display">\[f(x)\leq f(x^*).\]</span></p>
<div class="alert alert-info">
<p><strong>Exemplo.</strong> Seja <span class="math display">\[f(x)= -x^2.\]</span> Quando <span class="math inline">\(x=0\)</span>, teremos que <span class="math inline">\(f(0)=0\)</span>. Para qualquer outro valor de <span class="math inline">\(x\)</span>, teremos <span class="math inline">\(f(x)&lt;0\)</span>. Portanto, <span class="math display">\[f(x)\leq f(0)\]</span> e <span class="math inline">\(x^*=0\)</span> é o ponto de máximo.</p>
</div>
<div class="alert alert-info">
<p><strong>Exemplo.</strong> Seja <span class="math display">\[f(x)= I(0\leq x \leq 2).\]</span></p>
<p>Quando <span class="math inline">\(x\notin[0,2]\)</span>, teremos que <span class="math inline">\(f(x)=0\)</span>. Para qualquer valor de <span class="math inline">\(x\in[0,2]\)</span>, teremos <span class="math inline">\(f(x)=1\)</span>. Portanto, <span class="math display">\[f(x)\leq f(x^*)\]</span> onde <span class="math inline">\(x^*\)</span> é qualquer ponto dentro do intervalo <span class="math inline">\([0,1]\)</span>. Nesse caso, existem infinitos pontos de máximo.</p>
</div>
<div class="alert alert-info">
<p><strong>Exemplo.</strong> Seja</p>
<p><span class="math display">\[f(x)= xI(0\leq x &lt; 2).\]</span></p>
<p>Quando <span class="math inline">\(x\notin[0,2)\)</span>, teremos que <span class="math inline">\(f(x)=0\)</span>. Para qualquer valor de <span class="math inline">\(x\in[0,2)\)</span>, teremos <span class="math inline">\(f(x)=x\)</span>.</p>
<p>Sabemos que, quanto mais próximo de 2, maior é o valor de <span class="math inline">\(x\)</span>. Entretanto, como <span class="math inline">\(f(2)=0\)</span>, temos que o máximo não está definido.</p>
</div>
<p>Quando <span class="math inline">\(f(x)\)</span> é contínua, podemos procurar numericamente pelo ponto de máximo utilizando um algoritmo de subida de montanha.</p>
<div class="alert alert-danger">
<p><strong>Algoritmo de subida de montanha</strong></p>
<p>Seja <span class="math inline">\(f(x)\)</span> uma função contínua no domínio <span class="math inline">\(D\subseteq \mathbb{R}\)</span>. Escolha um valor <span class="math inline">\(m^{(1)}\)</span> como candidato a ponto máximo. Fixe <span class="math inline">\(\delta&gt;0\)</span> pequeno. Na <span class="math inline">\(j\)</span>-ésima iteração</p>
<ol type="1">
<li><p>Compute <span class="math inline">\(f(m^{(j)}-\delta)\)</span> e <span class="math inline">\(f(m^{(j)}+\delta)\)</span>.</p></li>
<li><p>Se <span class="math display">\[f(m^{(j)})&lt; f(m^{(j)}+\delta),\]</span> então <span class="math inline">\(m^{(j)}\)</span> não pode ser ponto de máximo. Crie um candidato novo <span class="math inline">\(m^{(j+1)}=m^{(j)}+\delta\)</span>.</p></li>
<li><p>Se <span class="math display">\[f(m^{(j)})&lt; f(m^{(j)}-\delta),\]</span> então <span class="math inline">\(m^{(j)}\)</span> não pode ser ponto de máximo. Crie um candidato novo <span class="math inline">\(m^{(j+1)}=m^{(j)}-\delta\)</span>.</p></li>
</ol>
<p>Repita o algoritmo até encontrar um ponto de máximo.</p>
</div>
<p>A figura abaixo apresenta uma função com diferentes regiões que podem interferir na determinação do ponto de máximo global via um algoritmo de subida de montanha. Os pontos em vermelho são diferentes valores iniciais para o algoritmo e os respectivos extremos dos segmentos vermelhos indicam os valores <span class="math inline">\(m-\delta\)</span> e <span class="math inline">\(m+\delta\)</span> que serão testados. Observe que:</p>
<ul>
<li><p>Ao começar em <span class="math inline">\(A\)</span>, o algoritmo encontra o ponto de máximo global.</p></li>
<li><p>Ao começar em <span class="math inline">\(B\)</span>, o algoritmo vai parar em um ponto de máximo local</p></li>
<li><p>Ao começar em <span class="math inline">\(C\)</span>, o algortimo vai parar em algum ponto do platô.</p></li>
</ul>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="pontual_files/figure-html/unnamed-chunk-8-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<div class="alert alert-success">
<p><strong>Definição</strong> Seja <span class="math inline">\(f\)</span> uma função definida em <span class="math inline">\(D\subseteq \mathbb{R}\)</span>. Dizemos que <span class="math inline">\(x^{*}\)</span> é um ponto de máximo local se, para algum <span class="math inline">\(B\subset D\)</span>, <span class="math display">\[f(x)\leq f(x^{*}),\;\;\forall\;\;x\in B.\]</span></p>
</div>
<p>Por definição, todo máximo global também é um máximo local. Vamos discutir em quais condições é possível encontrar os pontos de máximo locais. Considere que <span class="math inline">\(f(x)\)</span> é diferenciável para todo <span class="math inline">\(x\)</span> e que sua derivada é contínua. Como <span class="math inline">\(f'(x)\)</span> é o coeficiente angular da reta que passa tangente ao ponto <span class="math inline">\(x\)</span>, temos que <span class="math inline">\(x^*\)</span> ponto que satisfaz <span class="math inline">\(f'(x^*)=0\)</span> só pode ser um ponto de máximo (local), mínimo (local) ou ponto de inflexão (essas três possibilidades são denominadas pontos críticos). A figura abaixo ilustra essas três situações.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="pontual_files/figure-html/unnamed-chunk-9-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Para distinguir se o ponto crítico é um ponto de máximo local, devemos verificar a concavidade da função no ponto.</p>
<ul>
<li><p>se <span class="math inline">\(f''(x^*)&gt;0\)</span>, então a concavidade de <span class="math inline">\(f\)</span> no ponto <span class="math inline">\(x^*\)</span> é voltada para cima (no formato <span class="math inline">\(\cup\)</span>). Então <span class="math inline">\(x^*\)</span> é um ponto de mínimo local</p></li>
<li><p>se <span class="math inline">\(f''(x^*)&lt;0\)</span>, então a concavidade de <span class="math inline">\(f\)</span> no ponto <span class="math inline">\(x^*\)</span> é voltada para baixo (no formato <span class="math inline">\(\cap\)</span>). Então <span class="math inline">\(x^*\)</span> é um ponto de máximo local</p></li>
</ul>
<p>Portanto, desde que a função possua as duas derivadas contínuas, pode-se encontrar todos os pontos críticos e determinar o máximo global da função.</p>
<div class="alert alert-warning">
<p><strong>Importante.</strong> Em problemas de maximização, tanto analíticos quanto computacionais, é usual procupar pelo ponto de máximo global de <span class="math inline">\(f(x)\)</span> na função <span class="math inline">\(\log f(x)\)</span>. Para entender o motivo, observe que</p>
<ol type="1">
<li><p>Se <span class="math inline">\(f(x)\leq f(x^*)\)</span> para todo <span class="math inline">\(x\)</span>, então <span class="math inline">\(\log f(x)\leq \log f(x^*)\)</span>. Portanto, o ponto que maximiza <span class="math inline">\(f\)</span> também maximiza <span class="math inline">\(\log f\)</span> (e vice e versa)</p></li>
<li><p>Ao aplicar o logaritmo, produtos são transformados em somas e potências em multiplicaçõces. Desse modo, o cálculo das derivadas tendem a ser mais simples.<br>
</p></li>
</ol>
</div>
<div class="alert alert-info">
<p><strong>Exemplo.</strong> Seja <span class="math display">\[f(x)=\frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}\]</span> Vamos encontrar o ponto de máximo global dessa função. Primeiro, observe que <span class="math display">\[\log f(x)=\log\left(\frac{1}{\sqrt{2\pi}}\right)+\log\left(e^{-\frac{x^2}{2}}\right)=\log\left(\frac{1}{\sqrt{2\pi}}\right)-\frac{x^2}{2}\]</span> A primeira derivada da função acima é <span class="math display">\[\frac{d}{dx}\log f(x)=-x\]</span> e o ponto crítico <span class="math inline">\(x^*\)</span> é encontrado como segue: <span class="math display">\[-x^*=0\Rightarrow x^*=0\]</span></p>
<p>A segunda derivada da função é <span class="math display">\[\frac{d^2}{dx^2}\log f(x)=-1\]</span> Como essa derivada sempre é negativa, ela também o será para <span class="math inline">\(x^*\)</span>. Portanto <span class="math inline">\(x^*\)</span> é um ponto de máximo local. Como esse é o único ponto, ele também é o máximo global.</p>
</div>
<div class="alert alert-info">
<p><strong>Exemplo.</strong> Seja <span class="math display">\[f(x)=x^a(1-x)^b,\]</span> onde <span class="math inline">\(x\in(0,1)\)</span> e <span class="math inline">\(a,b&gt;0\)</span>. Vamos encontrar o ponto de máximo global dessa função. Primeiro, observe que <span class="math display">\[\log f(x)= a\log(x)+b\log(1-x)\]</span> A primeira derivada da função acima é <span class="math display">\[\frac{d}{dx}\log f(x)=\frac{a}{x}-\frac{b}{1-x}\]</span> e o ponto crítico <span class="math inline">\(x^*\)</span> é encontrado como segue: <span class="math display">\[\frac{a}{x^*}-\frac{b}{1-x^*}=0\Rightarrow a(1-x^*)-bx^{*}=0\Rightarrow x^*=\frac{a}{a+b}\]</span></p>
<p>A segunda derivada da função é <span class="math display">\[\frac{d^2}{dx^2}\log f(x)=-\frac{a}{x^2}-\frac{b}{(1-x)^2}.\]</span> Como essa derivada sempre é negativa, ela também o será para <span class="math inline">\(x^*\)</span>. Portanto <span class="math inline">\(x^*\)</span> é um ponto de máximo local. Como esse é o único ponto, ele também é o máximo global.</p>
</div>
<p>Observe que nem sempre teremos um ponto crítico, mas isso não implica na inexistência do ponto de máximo global. Entre os casos de interesse nesse curso, estão as funções monótonas em um intervalo.</p>
<div class="alert alert-success">
<p><strong>Definição</strong> Dizemos que <span class="math inline">\(f(x)\)</span> é monótona crescente no intervalo <span class="math inline">\(D\)</span> se, para quaisquer <span class="math inline">\(x&gt;y\in D\)</span>, <span class="math display">\[f(x)&lt;f(y).\]</span> Por outro lado, se para quaisquer <span class="math inline">\(x&gt;y\in D\)</span> se observar a relação <span class="math display">\[f(x)&gt;f(y),\]</span> então <span class="math inline">\(f(x)\)</span> será dita ser monótona decrescente no intervalo <span class="math inline">\(D\)</span>.</p>
</div>
<div class="alert alert-success">
<p><strong>Proposição.</strong></p>
<ol type="1">
<li>Se <span class="math inline">\(f'(x)&gt;0\)</span> para todo <span class="math inline">\(x\)</span>, então <span class="math inline">\(f\)</span> é monótona crescente.</li>
<li>Se <span class="math inline">\(f'(x)&lt;0\)</span> para todo <span class="math inline">\(x\)</span>, então <span class="math inline">\(f\)</span> é monótona decrescente.</li>
</ol>
</div>
<div class="alert alert-info">
<p><strong>Exemplo.</strong> Seja <span class="math display">\[f(x)=\log(x)I(0&lt;x\leq 4)\]</span> Observe que <span class="math display">\[\frac{d}{dx}f(x)=\frac{1}{x}I(0&lt;x\leq 4).\]</span> Observe que a derivada acima não pode ser nula no intervalo de interesse (<span class="math inline">\(D=(0,4]\)</span>). Como ela é sempre positiva, a função <span class="math inline">\(f\)</span> é monótona crescente. Como o maior valor possível em <span class="math inline">\(D\)</span> é 4, teremo que <span class="math inline">\(x^*=4\)</span> é o ponto de máximo global.</p>
</div>
<div class="alert alert-info">
<p><strong>Exemplo.</strong> Seja <span class="math display">\[f(x)=\frac{1}{x}I(x\geq 3)\]</span> Observe que <span class="math display">\[\frac{d}{dx}f(x)=-\frac{1}{x^2}I(x\geq 3).\]</span> Observe que a derivada acima não pode ser nula no intervalo de interesse (<span class="math inline">\(D=[3,\infty)\)</span>). Como ela é sempre negativa, a função <span class="math inline">\(f\)</span> é monótona decrescente. Como o menor valor possível em <span class="math inline">\(D\)</span> é 3, teremo que <span class="math inline">\(x^*=3\)</span> é o ponto de máximo global.</p>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./suficiencia.html" class="pagination-link" aria-label="Estatística">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Estatística</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./references.html" class="pagination-link" aria-label="References">
        <span class="nav-page-text">References</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>